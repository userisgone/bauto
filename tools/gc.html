<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GC Content with Sliding Window (Python via Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
  <style>
    body { font-family: sans-serif; padding: 1rem; max-width: 800px; margin: auto; }
    textarea { width: 100%; height: 120px; font-family: monospace; }
    canvas { width: 100%; height: 300px; border: 1px solid #ccc; }
    .controls { margin: 1rem 0; }
    input[type=number] { width: 80px; }
    #tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>

<h1>GC Content with Sliding Window (Python)</h1>

<label for="seq">Paste FASTA/sequence:</label>
<textarea id="seq">>Example
ATGCGCGTAGCTAGCGCGCGCGCTAGCTAGCTAGCGCGC</textarea>

<div class="controls">
  <label>Window size: <input type="number" id="win" value="10"></label>
  <label>Step size: <input type="number" id="step" value="5"></label>
  <button id="runBtn">Analyze</button>
</div>

<canvas id="plot"></canvas>
<div id="tooltip"></div>

<script>
  let pyodide = null;
  let points = [];
  let canvas = document.getElementById('plot');
  let tip = document.getElementById('tooltip');
  let ctx = canvas.getContext('2d');

  async function setup() {
    pyodide = await loadPyodide();
    await pyodide.runPythonAsync(`
def parse(seq):
    lines = seq.strip().split('\n')
    if lines[0].startswith('>'): lines = lines[1:]
    return ''.join(line.strip().upper() for line in lines if line.strip())

def sliding_gc(seq, win, step):
    out = []
    L = len(seq)
    for i in range(0, L - win + 1, step):
        sub = seq[i:i+win]
        gc = sum(1 for b in sub if b in 'GC')
        gc_pct = (gc / win) * 100
        out.append((i + 1, gc_pct))
    return out
    `);
  }

  document.getElementById('runBtn').addEventListener('click', async () => {
    const raw = document.getElementById('seq').value;
    const win = parseInt(document.getElementById('win').value);
    const step = parseInt(document.getElementById('step').value);

    const parsed = await pyodide.runPythonAsync(`parse(${JSON.stringify(raw)})`);
    const result = await pyodide.runPythonAsync(`sliding_gc(${JSON.stringify(parsed)}, ${win}, ${step})`);

    points = pyodide.toJs(result);
    drawChart(points);
  });

  function drawChart(data) {
    const width = canvas.width = canvas.clientWidth;
    const height = canvas.height = canvas.clientHeight;
    ctx.clearRect(0, 0, width, height);
    if (!data.length) return;

    const xVals = data.map(d => d[0]);
    const yVals = data.map(d => d[1]);
    const maxX = Math.max(...xVals);
    const maxY = 100;
    const pad = 40;

    ctx.beginPath();
    ctx.moveTo(pad, height - pad);
    for (let i = 0; i < data.length; i++) {
      const x = pad + (xVals[i] / maxX) * (width - 2 * pad);
      const y = height - pad - (yVals[i] / maxY) * (height - 2 * pad);
      ctx.lineTo(x, y);
    }
    ctx.strokeStyle = '#2c7';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  canvas.addEventListener('mousemove', ev => {
    if (!points.length) return;
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;

    const width = canvas.width;
    const height = canvas.height;
    const pad = 40;

    let best = null;
    let bestDist = Infinity;

    for (let i = 0; i < points.length; i++) {
      const [xval, yval] = points[i];
      const x = pad + (xval / points[points.length - 1][0]) * (width - 2 * pad);
      const y = height - pad - (yval / 100) * (height - 2 * pad);
      const dx = Math.abs(mx - x);
      const dy = Math.abs(my - y);
      const dist = dx * dx + dy * dy;
      if (dist < bestDist) {
        bestDist = dist;
        best = { x, y, xval, yval };
      }
    }

    if (bestDist < 400) {
      tip.style.left = (ev.clientX + 10) + 'px';
      tip.style.top = (ev.clientY + 10) + 'px';
      tip.innerHTML = `Start: ${best.xval} bp<br>GC: ${best.yval.toFixed(2)}%`;
      tip.style.display = 'block';
    } else {
      tip.style.display = 'none';
    }
  });

  setup();
</script>
</body>
</html>

